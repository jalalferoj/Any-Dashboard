<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Data Visualization Dashboard</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
        /* CSS Reset & Basic Setup */
        :root {
            --font-family: 'Inter', sans-serif;
            --transition-speed: 0.3s;
        }

        .light-mode {
            --bg-primary: #f4f7fa;
            --bg-secondary: #ffffff;
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --border-color: #e2e8f0;
            --accent-color: #3b82f6;
            --accent-color-hover: #2563eb;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --danger-color: #e53e3e;
            --danger-color-hover: #c53030;
        }

        .dark-mode {
            --bg-primary: #1a202c;
            --bg-secondary: #2d3748;
            --text-primary: #edf2f7;
            --text-secondary: #a0aec0;
            --border-color: #4a5568;
            --accent-color: #4299e1;
            --accent-color-hover: #3182ce;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --danger-color: #fc8181;
            --danger-color-hover: #f56565;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            line-height: 1.6;
        }

        /* Header & Controls */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px var(--shadow-color);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .btn, .file-upload-label {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color var(--transition-speed), transform var(--transition-speed);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--accent-color-hover);
            transform: translateY(-2px);
        }

        .file-upload-label {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .file-upload-label:hover {
            background-color: var(--border-color);
        }

        #file-input {
            display: none;
        }

        /* Theme Toggle */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
        }
        .theme-switch {
            display: inline-block;
            height: 24px;
            position: relative;
            width: 48px;
        }
        .theme-switch input {
            display:none;
        }
        .slider {
            background-color: #ccc;
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
        }
        .slider:before {
            background-color: #fff;
            bottom: 4px;
            content: "";
            height: 16px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 16px;
        }
        input:checked + .slider {
            background-color: var(--accent-color);
        }
        input:checked + .slider:before {
            transform: translateX(24px);
        }
        .slider.round {
            border-radius: 34px;
        }
        .slider.round:before {
            border-radius: 50%;
        }

        /* Main Content & Chart Grid */
        main {
            padding: 2rem;
        }
        
        .empty-state {
            text-align: center;
            padding: 4rem;
            background-color: var(--bg-secondary);
            border-radius: 8px;
            border: 2px dashed var(--border-color);
        }

        .empty-state h2 {
            font-size: 1.2rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        #chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
        }

        /* Chart Card Styling */
        .chart-card {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            display: flex;
            flex-direction: column;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed);
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .chart-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px var(--shadow-color);
        }

        .chart-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        
        .chart-header h3 {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .chart-controls {
            padding: 1rem 1.5rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .chart-controls select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-family);
        }

        .chart-container {
            flex-grow: 1;
            padding: 1.5rem;
            position: relative;
            min-height: 300px;
        }

        .chart-actions {
            display: flex;
            gap: 0.5rem;
        }

        .chart-actions .btn {
            padding: 0.4rem;
            background: none;
            color: var(--text-secondary);
            border: 1px solid transparent;
        }
        .chart-actions .btn:hover {
            color: var(--text-primary);
            background-color: var(--border-color);
        }
        .chart-actions .btn-danger:hover {
            color: white;
            background-color: var(--danger-color);
        }

        /* Loader */
        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .loader-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .loader {
            border: 5px solid var(--bg-secondary);
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            main {
                padding: 1rem;
            }
            #chart-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="loader-overlay" id="loader">
        <div class="loader"></div>
    </div>

    <header class="header">
        <h1>Dashboard</h1>
        <div class="controls">
            <label for="file-input" class="file-upload-label btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 6.5a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 1 1 .708-.708L7.5 10.793V7a.5.5 0 0 1 .5-.5z"/><path d="M4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H4zm0 1h8a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1z"/></svg>
                Upload CSV/Excel
            </label>
            <input type="file" id="file-input" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
            <button class="btn btn-primary" id="add-chart-btn" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
                Add Chart
            </button>
            <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-toggle">
                    <input type="checkbox" id="theme-toggle" />
                    <span class="slider round"></span>
                </label>
            </div>
        </div>
    </header>

    <main id="main-content">
        <div class="empty-state" id="empty-state">
            <h2>Upload a file to get started</h2>
            <p>Supported formats: CSV, XLSX, XLS</p>
        </div>
        <div id="chart-grid"></div>
    </main>

    <template id="chart-card-template">
        <div class="chart-card">
            <div class="chart-header">
                <div class="control-group" style="flex-grow: 1;">
                    <label>Chart Type</label>
                    <select class="chart-type-select"></select>
                </div>
                <div class="chart-actions">
                    <button class="btn export-btn" title="Export as PNG">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                    </button>
                    <button class="btn btn-danger remove-btn" title="Remove Chart">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                    </button>
                </div>
            </div>
            <div class="chart-controls">
                <div class="control-group">
                    <label>X-Axis (Category)</label>
                    <select class="x-axis-select"></select>
                </div>
                <div class="control-group">
                    <label>Y-Axis (Value)</label>
                    <select class="y-axis-select"></select>
                </div>
                <div class="control-group group-by-control" style="display: none;">
                    <label>Group By</label>
                    <select class="group-by-select"></select>
                </div>
            </div>
            <div class="chart-container">
                <canvas></canvas>
            </div>
        </div>
    </template>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- STATE MANAGEMENT ---
        let globalData = [];
        let globalHeaders = [];
        let chartInstances = new Map();

        // --- DOM ELEMENTS ---
        const fileInput = document.getElementById('file-input');
        const addChartBtn = document.getElementById('add-chart-btn');
        const chartGrid = document.getElementById('chart-grid');
        const emptyState = document.getElementById('empty-state');
        const mainContent = document.getElementById('main-content');
        const loader = document.getElementById('loader');
        const themeToggle = document.getElementById('theme-toggle');

        // --- CHART CONFIGURATION ---
        const CHART_TYPES = {
            'bar': 'Vertical Bar',
            'horizontalBar': 'Horizontal Bar',
            'groupedBar': 'Grouped Vertical Bar',
            'horizontalGroupedBar': 'Grouped Horizontal Bar',
            'stackedBar': 'Stacked Vertical Bar',
            'horizontalStackedBar': 'Stacked Horizontal Bar',
            'percentageStackedBar': '100% Stacked Vertical Bar',
            'horizontalPercentageStackedBar': '100% Stacked Horizontal Bar',
            'barWithLine': 'Bar with Line (Mixed)',
            'barWithDataLabels': 'Bar with Data Labels',
            'sortedBarAsc': 'Sorted Bar (Ascending)',
            'sortedBarDesc': 'Sorted Bar (Descending)',
            'barWithNegative': 'Bar with Negative Values',
            'floatingBar': 'Floating Bar (Range)',
            'roundedBar': 'Rounded Bar Chart',
            'customColorBar': 'Bar with Custom Colors',
            'dashedBorderBar': 'Bar with Dashed Border',
            'logarithmicBar': 'Logarithmic Y-Axis Bar',
            'tornado': 'Tornado Chart',
            'waterfall': 'Waterfall Chart'
        };

        // Predefined color palettes
        const COLOR_PALETTES = {
            default: ['#3b82f6', '#10b981', '#ef4444', '#f97316', '#8b5cf6', '#ec4899', '#6b7280'],
            vibrant: ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef'],
        };
        let currentPalette = COLOR_PALETTES.default;

        // Register Chart.js plugins
        Chart.register(ChartDataLabels);

        // --- EVENT LISTENERS ---
        fileInput.addEventListener('change', handleFileUpload);
        addChartBtn.addEventListener('click', addChartCard);
        chartGrid.addEventListener('change', handleChartControlChange);
        chartGrid.addEventListener('click', handleChartCardClick);
        themeToggle.addEventListener('change', toggleTheme);

        // --- THEME ---
        function setInitialTheme() {
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (localStorage.getItem('theme') === 'dark' || (localStorage.getItem('theme') === null && prefersDark)) {
                document.body.classList.add('dark-mode');
                document.body.classList.remove('light-mode');
                themeToggle.checked = true;
            } else {
                document.body.classList.add('light-mode');
                document.body.classList.remove('dark-mode');
            }
        }
        
        function toggleTheme() {
            if (themeToggle.checked) {
                document.body.classList.add('dark-mode');
                document.body.classList.remove('light-mode');
                localStorage.setItem('theme', 'dark');
            } else {
                document.body.classList.add('light-mode');
                document.body.classList.remove('dark-mode');
                localStorage.setItem('theme', 'light');
            }
            // Redraw all charts to adapt to new theme
            chartInstances.forEach(chart => {
                updateChartOptions(chart);
                chart.update();
            });
        }
        
        // --- FILE HANDLING ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoader(true);
            const reader = new FileReader();

            reader.onload = e => {
                const data = e.target.result;
                const fileExtension = file.name.split('.').pop().toLowerCase();
                
                if (fileExtension === 'csv') {
                    parseCSV(data);
                } else if (['xlsx', 'xls'].includes(fileExtension)) {
                    parseExcel(data);
                } else {
                    alert('Unsupported file format. Please upload a CSV or Excel file.');
                    showLoader(false);
                }
            };

            reader.onerror = () => {
                alert('Error reading file.');
                showLoader(false);
            };

            if (['xlsx', 'xls'].includes(file.name.split('.').pop().toLowerCase())) {
                reader.readAsArrayBuffer(data);
            } else {
                reader.readAsText(file);
            }
        }
        
        function parseCSV(csvData) {
            Papa.parse(csvData, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: true,
                complete: (results) => processParsedData(results.data),
                error: () => { 
                    alert('Error parsing CSV file.');
                    showLoader(false);
                }
            });
        }

        function parseExcel(excelData) {
            try {
                const workbook = XLSX.read(excelData, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: null });
                processParsedData(jsonData);
            } catch (error) {
                alert('Error parsing Excel file.');
                showLoader(false);
            }
        }

        function processParsedData(data) {
            if (!data || data.length === 0) {
                alert('No data found in the file.');
                showLoader(false);
                return;
            }

            globalData = data;
            globalHeaders = Object.keys(data[0]);

            // Clean up UI
            resetDashboard();
            emptyState.style.display = 'none';
            addChartBtn.disabled = false;
            addChartCard(); // Add one chart by default
            showLoader(false);
        }

        function resetDashboard() {
            chartInstances.forEach(chart => chart.destroy());
            chartInstances.clear();
            chartGrid.innerHTML = '';
        }

        // --- CHART CARD MANAGEMENT ---
        function addChartCard() {
            const template = document.getElementById('chart-card-template');
            const newCard = template.content.cloneNode(true).firstElementChild;
            const cardId = `chart-${Date.now()}`;
            newCard.id = cardId;
            
            // Populate dropdowns
            const chartTypeSelect = newCard.querySelector('.chart-type-select');
            const xAxisSelect = newCard.querySelector('.x-axis-select');
            const yAxisSelect = newCard.querySelector('.y-axis-select');
            const groupBySelect = newCard.querySelector('.group-by-select');

            Object.entries(CHART_TYPES).forEach(([key, value]) => {
                const option = new Option(value, key);
                chartTypeSelect.add(option);
            });

            ['(Select Column)', ...globalHeaders].forEach(header => {
                xAxisSelect.add(new Option(header, header));
                yAxisSelect.add(new Option(header, header));
                groupBySelect.add(new Option(header, header));
            });

            chartGrid.appendChild(newCard);
        }

        function handleChartControlChange(event) {
            if (event.target.matches('select')) {
                const card = event.target.closest('.chart-card');
                updateChart(card);
            }
        }

        function handleChartCardClick(event) {
            const btn = event.target.closest('button');
            if (!btn) return;
            const card = btn.closest('.chart-card');

            if (btn.classList.contains('remove-btn')) {
                if (chartInstances.has(card.id)) {
                    chartInstances.get(card.id).destroy();
                    chartInstances.delete(card.id);
                }
                card.style.animation = 'fadeOut 0.3s forwards';
                card.addEventListener('animationend', () => card.remove());
            } else if (btn.classList.contains('export-btn')) {
                exportChart(card);
            }
        }
        
        function exportChart(card) {
            const chartInstance = chartInstances.get(card.id);
            if (!chartInstance) return;
            const link = document.createElement('a');
            link.href = chartInstance.toBase64Image();
            link.download = `${card.querySelector('.chart-type-select option:checked').textContent.replace(/\s/g, '_')}.png`;
            link.click();
        }

        // --- CHART GENERATION & UPDATING ---
        function updateChart(card) {
            const cardId = card.id;
            const chartType = card.querySelector('.chart-type-select').value;
            const xCol = card.querySelector('.x-axis-select').value;
            const yCol = card.querySelector('.y-axis-select').value;
            const groupByCol = card.querySelector('.group-by-select').value;
            const groupByControl = card.querySelector('.group-by-control');
            
            // Show 'Group By' only for relevant charts
            const needsGroupBy = ['groupedBar', 'horizontalGroupedBar', 'stackedBar', 'horizontalStackedBar', 'percentageStackedBar', 'horizontalPercentageStackedBar', 'tornado'].includes(chartType);
            groupByControl.style.display = needsGroupBy ? 'flex' : 'none';

            if (xCol === '(Select Column)' || yCol === '(Select Column)' || (needsGroupBy && groupByCol === '(Select Column)')) {
                return;
            }

            const ctx = card.querySelector('canvas').getContext('2d');
            const config = getChartConfig(chartType, xCol, yCol, groupByCol);
            
            if (chartInstances.has(cardId)) {
                chartInstances.get(cardId).destroy();
            }
            
            const newChart = new Chart(ctx, config);
            chartInstances.set(cardId, newChart);
        }
        
        function updateChartOptions(chartInstance) {
            const isDarkMode = document.body.classList.contains('dark-mode');
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDarkMode ? '#edf2f7' : '#1a202c';

            chartInstance.options.scales.x.grid.color = gridColor;
            chartInstance.options.scales.y.grid.color = gridColor;
            chartInstance.options.scales.x.ticks.color = textColor;
            chartInstance.options.scales.y.ticks.color = textColor;
            chartInstance.options.plugins.legend.labels.color = textColor;
            chartInstance.options.plugins.title.color = textColor;
        }
        
        function getChartConfig(type, xCol, yCol, groupByCol) {
            const isDarkMode = document.body.classList.contains('dark-mode');
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDarkMode ? '#edf2f7' : '#1a202c';
            
            // Data Aggregation
            const aggregatedData = {};
            globalData.forEach(row => {
                const xValue = row[xCol];
                const yValue = parseFloat(row[yCol]);
                if (xValue === null || isNaN(yValue)) return;
                
                if (!aggregatedData[xValue]) aggregatedData[xValue] = 0;
                aggregatedData[xValue] += yValue;
            });
            
            let labels = Object.keys(aggregatedData);
            let data = Object.values(aggregatedData);

            // Base Config
            let config = {
                type: 'bar',
                data: { labels, datasets: [{ label: yCol, data, backgroundColor: currentPalette, borderColor: currentPalette, borderWidth: 1 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: textColor } },
                        title: { display: true, text: `${CHART_TYPES[type]}: ${yCol} by ${xCol}`, color: textColor },
                        datalabels: { display: false }
                    },
                    scales: {
                        x: { grid: { color: gridColor }, ticks: { color: textColor } },
                        y: { grid: { color: gridColor }, ticks: { color: textColor } }
                    }
                }
            };
            
            // --- CHART TYPE SPECIFIC CONFIGURATIONS ---
            const needsGroupBy = ['groupedBar', 'horizontalGroupedBar', 'stackedBar', 'horizontalStackedBar', 'percentageStackedBar', 'horizontalPercentageStackedBar', 'tornado'].includes(type);
            if (needsGroupBy) {
                const groupedData = {};
                const xValues = new Set();
                const groupValues = new Set();
                globalData.forEach(row => {
                    const x = row[xCol];
                    const group = row[groupByCol];
                    const y = parseFloat(row[yCol]);
                    if (x === null || group === null || isNaN(y)) return;
                    
                    xValues.add(x);
                    groupValues.add(group);
                    
                    if (!groupedData[group]) groupedData[group] = {};
                    if (!groupedData[group][x]) groupedData[group][x] = 0;
                    groupedData[group][x] += y;
                });
                
                const sortedX = Array.from(xValues).sort();
                const sortedGroups = Array.from(groupValues).sort();
                
                config.data.labels = sortedX;
                config.data.datasets = sortedGroups.map((group, i) => {
                    return {
                        label: group,
                        data: sortedX.map(x => groupedData[group][x] || 0),
                        backgroundColor: currentPalette[i % currentPalette.length],
                    };
                });
            }

            switch (type) {
                case 'horizontalBar':
                case 'horizontalGroupedBar':
                case 'horizontalStackedBar':
                case 'horizontalPercentageStackedBar':
                    config.options.indexAxis = 'y';
                    break;
                case 'stackedBar':
                case 'horizontalStackedBar':
                    config.options.scales.x.stacked = true;
                    config.options.scales.y.stacked = true;
                    break;
                case 'percentageStackedBar':
                case 'horizontalPercentageStackedBar':
                    config.options.scales.x.stacked = true;
                    config.options.scales.y.stacked = true;
                    config.options.plugins.tooltip = { callbacks: { label: (c) => `${c.dataset.label}: ${c.raw.toFixed(1)}%` } };
                    const totals = {};
                    config.data.labels.forEach(label => { totals[label] = 0; });
                    config.data.datasets.forEach(dataset => {
                        dataset.data.forEach((val, i) => {
                           totals[config.data.labels[i]] += val;
                        });
                    });
                    config.data.datasets.forEach(dataset => {
                        dataset.data = dataset.data.map((val, i) => (val / totals[config.data.labels[i]] * 100) || 0);
                    });
                    break;
                case 'barWithLine':
                    config.data.datasets.push({
                        type: 'line',
                        label: `Average ${yCol}`,
                        data: data.map(() => data.reduce((a, b) => a + b, 0) / data.length),
                        borderColor: '#ff6384',
                        backgroundColor: '#ff6384',
                        fill: false,
                    });
                    break;
                case 'barWithDataLabels':
                    config.options.plugins.datalabels = { 
                        display: true, 
                        anchor: 'end', 
                        align: 'top', 
                        color: textColor, 
                        formatter: (value) => Math.round(value * 100) / 100
                    };
                    break;
                case 'sortedBarAsc':
                case 'sortedBarDesc':
                    const zipped = labels.map((label, i) => ({label, value: data[i]}));
                    zipped.sort((a, b) => type === 'sortedBarAsc' ? a.value - b.value : b.value - a.value);
                    config.data.labels = zipped.map(d => d.label);
                    config.data.datasets[0].data = zipped.map(d => d.value);
                    break;
                case 'barWithNegative': // Data is already handled, this is for demonstration
                    break;
                case 'floatingBar':
                    // Assumes Y-Axis data is formatted as 'min-max', e.g., '10-50'
                    config.data.datasets[0].data = globalData.map(row => (row[yCol] || "0-0").split('-').map(Number)).filter(d => d.length === 2);
                    config.data.labels = globalData.map(row => row[xCol]).slice(0, config.data.datasets[0].data.length);
                    break;
                case 'roundedBar':
                    config.data.datasets.forEach(ds => { ds.borderRadius = 5; });
                    break;
                case 'customColorBar':
                    config.data.datasets[0].backgroundColor = COLOR_PALETTES.vibrant;
                    break;
                case 'dashedBorderBar':
                    config.data.datasets[0].borderDash = [5, 5];
                    config.data.datasets[0].borderWidth = 2;
                    break;
                case 'logarithmicBar':
                    config.options.scales.y.type = 'logarithmic';
                    break;
                case 'tornado':
                    if (config.data.datasets.length >= 2) {
                        config.options.indexAxis = 'y';
                        config.options.scales.x.stacked = true;
                        config.data.datasets[0].data = config.data.datasets[0].data.map(d => -d); // Make first dataset negative
                        config.options.plugins.tooltip = { callbacks: { label: c => `${c.dataset.label}: ${Math.abs(c.raw)}` }};
                        config.options.scales.x.ticks = { callback: v => Math.abs(v) };
                    }
                    break;
                case 'waterfall':
                    // This is a simplified waterfall; true waterfall often needs custom logic
                    config.type = 'bar';
                    const waterfallData = [data[0]];
                    for(let i = 1; i < data.length; i++) {
                        waterfallData.push(data[i] - data[i-1]);
                    }
                    config.data.datasets[0].data = waterfallData;
                    config.data.datasets[0].backgroundColor = waterfallData.map(v => v >= 0 ? 'rgba(75, 192, 192, 0.8)' : 'rgba(255, 99, 132, 0.8)');
                    config.options.plugins.title.text = `Waterfall Chart (Change over ${xCol})`;
                    break;
            }
            return config;
        }

        // --- UTILITY FUNCTIONS ---
        function showLoader(show) {
            loader.classList.toggle('show', show);
        }

        // --- INITIALIZATION ---
        setInitialTheme();
    });
    </script>
</body>
</html>